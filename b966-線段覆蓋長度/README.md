一開始本來想要用扣的但感覺不是很好做<br>
所以換個想法<br>
用pair<int,int> rope[]存每一小線段的左右端點<br>
然後設新大線段的起始點跟終點為-1<br>
排序後從左向右掃<br>
如果rope[i]的左端點大於原本大線段的終點<br>
>代表原大線段結束 接下來就是新的大線段<br>
>或者說此小線段與目前的大線段無交集<br>
>將答案加上原終點-原起點<br>
>再把起點、終點個自更新成rope[i]的左、右端點<br>

若上述情況未發生<br>
>代表還是同一個大線段<br>
>可能是部分交集或小線段包含於大線段中<br>
>這樣就只要將終點設成max(rope[i]右端點,終點)<br>
>(老實說就算是新線段還是能用max(該點右端點,終點) 所以我偷懶沒用流程控制區隔開)<br>
>講白話一點就是
>>部分交集--延長右端點<br>
>>完全包含--保持原樣<br>
>
>只是可以用一行直接表示 不用額外分析<br>

另外 雖然資料倆倆一組且要排序 但還是不適合用map<br>
應該會有重複端點的問題
