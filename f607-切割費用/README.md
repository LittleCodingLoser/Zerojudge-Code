這題真的太有趣，每次學了新觀念都能回來解這題<br>
<解法一><br>
一開始剛學STL用set解，用一點反向思考<br>
先存一個以切割順序為index，切割位置為value的陣列<br>
然後從最後切割的開始跑迴圈<br>
用.find()找到該點位置後用*next-*prev得到該段費用<br>
再pop該點<br>
<解法二><br>
之後學了二分搜，突然發現這題也適用<br>
但就用vector當容器，且是用正面思考<br>
一樣先存一個以切割順序為index，切割位置為value的陣列<br>
從第一個切割的點開始跑迴圈<br>
先搜到第一個大於欲切割點的位置<br>
再用第一個大於-第一個小於<br>
最後insert該切割點於第一個大於的前面<br>
速度比我預期的快 AC (66ms, 2.9MB)<br>
<解法三><br>
這個做法只是把解法二的vector改成最近學的linked list<br>
本來以為可以省略insert用移動節點來加速<br>
結果比解法二慢 	AC (71ms, 3.4MB)<br>
或許是因為二分搜<br>
解法二vector長度由短到長，進而使二分搜變快<br>
解法三長度一直是n<br>
解法三應該還能優化，有變快會再更新<br>
